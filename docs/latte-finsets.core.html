<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-finsets.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-finsets</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="latte-finsets.core.html"><div class="inner"><span>latte-finsets.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-finsets.core.html#var-card-emptyset"><div class="inner"><span>card-emptyset</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-card-emptyset-thm"><div class="inner"><span>card-emptyset-thm</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted"><div class="inner"><span>counted</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-def"><div class="inner"><span>counted-def</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-elim-pbijective"><div class="inner"><span>counted-elim-pbijective</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-elim-pbijective-thm"><div class="inner"><span>counted-elim-pbijective-thm</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-elim-pfun"><div class="inner"><span>counted-elim-pfun</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-elim-pfun-thm"><div class="inner"><span>counted-elim-pfun-thm</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-intro"><div class="inner"><span>counted-intro</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-counted-intro-thm"><div class="inner"><span>counted-intro-thm</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-decompose-counted-type"><div class="inner"><span>decompose-counted-type</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-decomposer-counted-type"><div class="inner"><span>decomposer-counted-type</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-finite"><div class="inner"><span>finite</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-finite-def"><div class="inner"><span>finite-def</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-finite-emptyset"><div class="inner"><span>finite-emptyset</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-finite-emptyset-thm"><div class="inner"><span>finite-emptyset-thm</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-finite-singleton"><div class="inner"><span>finite-singleton</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert"><div class="inner"><span>insert</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert-count"><div class="inner"><span>insert-count</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert-def"><div class="inner"><span>insert-def</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert-prop-elem"><div class="inner"><span>insert-prop-elem</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert-prop-idem"><div class="inner"><span>insert-prop-idem</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert-prop-neq"><div class="inner"><span>insert-prop-neq</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-insert-prop-set"><div class="inner"><span>insert-prop-set</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-one-count"><div class="inner"><span>one-count</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-range"><div class="inner"><span>range</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-range-empty"><div class="inner"><span>range-empty</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-range-eq"><div class="inner"><span>range-eq</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-range-one"><div class="inner"><span>range-one</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-singleton"><div class="inner"><span>singleton</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-singleton-def"><div class="inner"><span>singleton-def</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-singleton-thm"><div class="inner"><span>singleton-thm</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-the-card"><div class="inner"><span>the-card</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-the-card-ax"><div class="inner"><span>the-card-ax</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-the-card-prop"><div class="inner"><span>the-card-prop</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-the-card-prop-ax"><div class="inner"><span>the-card-prop-ax</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-the-card-singleton"><div class="inner"><span>the-card-singleton</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-the-card-singleton-prop"><div class="inner"><span>the-card-singleton-prop</span></div></a></li><li class="depth-1"><a href="latte-finsets.core.html#var-zero-count"><div class="inner"><span>zero-count</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-finsets.core</h1><div class="doc"><div class="markdown"><p>The formalization of finite sets.</p></div></div><div class="public anchor" id="var-card-emptyset"><h3>card-emptyset</h3><div class="usage"><code>(card-emptyset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(card-emptyset-thm T (zero-count T))
</code></pre>
<p><strong>Definition</strong>: The cardinal of the emptyset is zero.</p></div></div></div><div class="public anchor" id="var-card-emptyset-thm"><h3>card-emptyset-thm</h3><div class="usage"><code>(card-emptyset-thm [T :type] [cf (rel T int)])</code></div><div class="doc"><div class="markdown"><pre><code>(= (the-card (emptyset-counted T cf)) zero)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-counted"><h3>counted</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(counted s cf n)</code></p>
<p>The set <code>s</code> is counted from 1 to <code>n</code>, cf. <a href="latte-finsets.core.html#var-counted-def">counted-def</a></p></div></div></div><div class="public anchor" id="var-counted-def"><h3>counted-def</h3><div class="usage"><code>(counted-def [T :type] [s (set T)] [cf (rel T int)] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(and (pfun cf s (range one n)) (pfun/pbijective cf s (range one n)))
</code></pre>
<p><strong>Definition</strong>: The set <code>s</code> is counted from 1 to <code>n</code></p></div></div></div><div class="public anchor" id="var-counted-elim-pbijective"><h3>counted-elim-pbijective</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(counted-elim-pbijective s cf n)</code></p>
<p>The first elimination rule for the <a href="latte-finsets.core.html#var-counted">counted</a> predicate: the counted relation must be a biject with <code>(range 1 n)</code>the counted relation, cf. <a href="latte-finsets.core.html#var-counted-elim-pbijective-thm">counted-elim-pbijective-thm</a>.</p></div></div></div><div class="public anchor" id="var-counted-elim-pbijective-thm"><h3>counted-elim-pbijective-thm</h3><div class="usage"><code>(counted-elim-pbijective-thm [T :type] [s (set T)] [cf (rel T int)] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (counted s cf n) (pfun/pbijective cf s (range one n)))
</code></pre>
<p><strong>Theorem</strong>: The second elimination rule for the <a href="latte-finsets.core.html#var-counted">counted</a> predicate: the counted relation must be a biject with <code>(range 1 n)</code>.</p></div></div></div><div class="public anchor" id="var-counted-elim-pfun"><h3>counted-elim-pfun</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(counted-elim-pfun s cf n)</code></p>
<p>The first elimination rule for the <a href="latte-finsets.core.html#var-counted">counted</a> predicate: the counted relation must be a partial function, cf. <a href="latte-finsets.core.html#var-counted-elim-pfun-thm">counted-elim-pfun-thm</a>.</p></div></div></div><div class="public anchor" id="var-counted-elim-pfun-thm"><h3>counted-elim-pfun-thm</h3><div class="usage"><code>(counted-elim-pfun-thm [T :type] [s (set T)] [cf (rel T int)] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (counted s cf n) (pfun cf s (range one n)))
</code></pre>
<p><strong>Theorem</strong>: The first elimination rule for the <a href="latte-finsets.core.html#var-counted">counted</a> predicate: the counted relation must be a partial function.</p></div></div></div><div class="public anchor" id="var-counted-intro"><h3>counted-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(counted-intro s cf n)</code></p>
<p>The introduction rule for the <a href="latte-finsets.core.html#var-counted">counted</a> predicate, cf. <a href="latte-finsets.core.html#var-counted-intro-thm">counted-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-counted-intro-thm"><h3>counted-intro-thm</h3><div class="usage"><code>(counted-intro-thm [T :type] [s (set T)] [cf (rel T int)] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (pfun cf s (range one n))
 (pfun/pbijective cf s (range one n))
 (counted s cf n))
</code></pre>
<p><strong>Theorem</strong>: The introduction rule for the counted predicate.</p></div></div></div><div class="public anchor" id="var-decompose-counted-type"><h3>decompose-counted-type</h3><div class="usage"><code>(decompose-counted-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decomposer-counted-type"><h3>decomposer-counted-type</h3><div class="usage"><code>(decomposer-counted-type t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-finite"><h3>finite</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(finite s cf)</code></p>
<p>The set <code>s</code> is finite according to counting function <code>cf</code>, see <a href="latte-finsets.core.html#var-finite-def">finite-def</a>.</p></div></div></div><div class="public anchor" id="var-finite-def"><h3>finite-def</h3><div class="usage"><code>(finite-def [T :type] [s (set T)] [cf (rel T int)])</code></div><div class="doc"><div class="markdown"><pre><code>(exists [n int] (counted s cf n))
</code></pre>
<p><strong>Definition</strong>: The definition of a finite set: <code>s</code> is finite if the function <code>cf</code> counts the number <code>n</code> of elements in <code>s</code>,  see <a href="latte-finsets.core.html#var-counted">counted</a>.</p></div></div></div><div class="public anchor" id="var-finite-emptyset"><h3>finite-emptyset</h3><div class="usage"><code>(finite-emptyset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(finite-emptyset-thm T (zero-count T))
</code></pre>
<p><strong>Definition</strong>: The emptyset is finite.</p></div></div></div><div class="public anchor" id="var-finite-emptyset-thm"><h3>finite-emptyset-thm</h3><div class="usage"><code>(finite-emptyset-thm [T :type] [cf (rel T int)])</code></div><div class="doc"><div class="markdown"><pre><code>(finite (set/emptyset T) cf)
</code></pre>
<p><strong>Theorem</strong>: The emptyset of type <code>T</code> is finite, whatever the counting function.</p></div></div></div><div class="public anchor" id="var-finite-singleton"><h3>finite-singleton</h3><div class="usage"><code>(finite-singleton [T :type] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(finite (singleton x) (one-count T))
</code></pre>
<p><strong>Theorem</strong>: The emptyset of type <code>T</code> is finite, whatever the counting function.</p></div></div></div><div class="public anchor" id="var-insert"><h3>insert</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(insert x s)</code></p>
<p>Insertion of element <code>x</code> in set <code>s</code>, cf. <a href="latte-finsets.core.html#var-insert-def">insert-def</a>.</p></div></div></div><div class="public anchor" id="var-insert-count"><h3>insert-count</h3><div class="usage"><code>(insert-count [T :type] [s (set T)] [size int])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda
 [y T]
 (lambda
  [k int]
  (and
   (==&gt; (elem y s) (= k size))
   (==&gt; (not (elem y s)) (= k (succ size))))))
</code></pre>
<p><strong>Definition</strong>: </p></div></div></div><div class="public anchor" id="var-insert-def"><h3>insert-def</h3><div class="usage"><code>(insert-def [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [y T] (or (equal y x) (elem y s)))
</code></pre>
<p><strong>Definition</strong>: Insertion of element <code>x</code> in set <code>s</code>.</p></div></div></div><div class="public anchor" id="var-insert-prop-elem"><h3>insert-prop-elem</h3><div class="usage"><code>(insert-prop-elem [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(elem x (insert x s))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-insert-prop-idem"><h3>insert-prop-idem</h3><div class="usage"><code>(insert-prop-idem [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem x s) (seteq s (insert x s)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-insert-prop-neq"><h3>insert-prop-neq</h3><div class="usage"><code>(insert-prop-neq [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [y T] (==&gt; (elem y (insert x s)) (not (equal y x)) (elem y s)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-insert-prop-set"><h3>insert-prop-set</h3><div class="usage"><code>(insert-prop-set [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [y T] (==&gt; (elem y s) (elem y (insert x s))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-one-count"><h3>one-count</h3><div class="usage"><code>(one-count [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [k int] (= k one)))
</code></pre>
<p><strong>Definition</strong>: The counting relation for singletons.</p></div></div></div><div class="public anchor" id="var-range"><h3>range</h3><div class="usage"><code>(range [m int] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [k int] (and (&lt;= m k) (&lt;= k n)))
</code></pre>
<p><strong>Definition</strong>: The range set from <code>m</code> to <code>n</code>.</p></div></div></div><div class="public anchor" id="var-range-empty"><h3>range-empty</h3><div class="usage"><code>(range-empty [m int] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt; n m) (forall [k int] (not (elem k (range m n)))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-range-eq"><h3>range-eq</h3><div class="usage"><code>(range-eq [m int] [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (= m n) (forall [k int] (==&gt; (elem k (range m n)) (= k n))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-range-one"><h3>range-one</h3><div class="usage"><code>(range-one [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [k int (range n n)] (= k n))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-singleton"><h3>singleton</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(singleton x)</code></p>
<p>The singleton set <code>{x}</code>, cf. <a href="latte-finsets.core.html#var-singleton-def">singleton-def</a>.</p></div></div></div><div class="public anchor" id="var-singleton-def"><h3>singleton-def</h3><div class="usage"><code>(singleton-def [T :type] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [y T] (equal x y))
</code></pre>
<p><strong>Definition</strong>: The singleton set <code>{x}</code>.</p></div></div></div><div class="public anchor" id="var-singleton-thm"><h3>singleton-thm</h3><div class="usage"><code>(singleton-thm [T :type] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(elem x (singleton x))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-the-card"><h3>the-card</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(the-card cnt)</code></p>
<p>The cardinal number of a set counted by <code>cnt</code> of type <code>(counted s cf n)</code>,  cf. <a href="latte-finsets.core.html#var-counted">counted</a>.</p></div></div></div><div class="public anchor" id="var-the-card-ax"><h3>the-card-ax</h3><div class="usage"><code>(the-card-ax [T :type] [s (set T)] [cf (rel T int)] [n int] [cnt (counted s cf n)])</code></div><div class="doc"><div class="markdown"><pre><code>int
</code></pre>
<p><strong>Axiom</strong>: The axiomatic definition of the cardinal number for finite sets.</p></div></div></div><div class="public anchor" id="var-the-card-prop"><h3>the-card-prop</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(the-card-prop cnt)</code></p>
<p>The defining property of the cardinal number of a finite set. The <code>cnt</code> argument is a proof that the set can be counted,  of type <code>(counted s cf n)</code>, cf. <a href="latte-finsets.core.html#var-the-card-prop-ax">the-card-prop-ax</a>.</p></div></div></div><div class="public anchor" id="var-the-card-prop-ax"><h3>the-card-prop-ax</h3><div class="usage"><code>(the-card-prop-ax [T :type] [s (set T)] [cf (rel T int)] [n int] [cnt (counted s cf n)])</code></div><div class="doc"><div class="markdown"><pre><code>(= (the-card cnt) n)
</code></pre>
<p><strong>Axiom</strong>: The defining axiomatic property of the cardinal number for finite sets.</p></div></div></div><div class="public anchor" id="var-the-card-singleton"><h3>the-card-singleton</h3><div class="usage"><code>(the-card-singleton [T :type] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(the-card (singleton-counted T x))
</code></pre>
<p><strong>Definition</strong>: The cardinal of the singleton set <code>{x}</code>.</p></div></div></div><div class="public anchor" id="var-the-card-singleton-prop"><h3>the-card-singleton-prop</h3><div class="usage"><code>(the-card-singleton-prop [T :type] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(= (the-card-singleton T x) one)
</code></pre>
<p><strong>Theorem</strong>: The cardinal of a singleton is <code>one</code>.</p></div></div></div><div class="public anchor" id="var-zero-count"><h3>zero-count</h3><div class="usage"><code>(zero-count [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [k int] (= k zero)))
</code></pre>
<p><strong>Definition</strong>: This is a dummy counting function for use in <a href="latte-finsets.core.html#var-finite-emptyset">finite-emptyset</a>.</p></div></div></div></div></body></html>